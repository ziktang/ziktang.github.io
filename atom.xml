<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ziktang的个人博客</title>
  <subtitle>ziktang的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-15T03:23:27.970Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>不会上树的猴子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java并发与多线程总结</title>
    <link href="http://yoursite.com/2017/03/15/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/03/15/Java并发总结/</id>
    <published>2017-03-15T03:11:15.174Z</published>
    <updated>2017-03-15T03:23:27.970Z</updated>
    
    <content type="html"><![CDATA[<p>##<strong>1.多线程的优点</strong></p>
<ul>
<li>资源利用率更好</li>
<li>程序在某些情况下更简单</li>
<li>程序响应更快</li>
</ul>
<h2 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2.创建线程"></a><strong>2.创建线程</strong></h2><p>###<strong>1.实现Runnable接口</strong><br>new Thread(Runnable).start()</p>
<ul>
<li>可以避免由于java单继承带来的局限</li>
<li>增强程序的健壮性，代码能够被多个线程共享，代码和数据是=数据是独立的</li>
<li>适合多个相同程序代码的线程区处理同意资源的情况</li>
</ul>
<p>###<strong>2.继承Thread类</strong><br>new MyThread().start()</p>
<blockquote>
<p>注意:启动线程的方式必须是start(),若是直接调用Thread.run()代码也能执行，但是就变成了普通方法的调用了，并没有启动线程</p>
</blockquote>
<p>##<strong>3.线程状态</strong></p>
<p>###<strong>1.线程状态介绍</strong><br>线程在一定条件下，状态会发生变化。线程一共有以下几种状态：</p>
<ul>
<li><p>新建状态(New)：新创建了一个线程对象。</p>
</li>
<li><p>就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</p>
</li>
<li><p>运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。</p>
</li>
<li><p>阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种:</p>
<ul>
<li><p>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“<strong>等待池</strong>”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，</p>
</li>
<li><p>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“<strong>锁池</strong>”中。</p>
</li>
<li><p>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
</li>
</ul>
</li>
<li><p>死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
</li>
</ul>
<p><img src="http://omu5mmfy7.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="线程状态图"></p>
<p>###<strong>2.中断机制</strong></p>
<ul>
<li><p>可中断的阻塞状态：Thread.sleep(),Object.wait(),Thread.join(),ReenTrantLock.lockInterruptibly()。</p>
</li>
<li><p>不可中断的阻塞状态：<br>synchronized和I/O阻塞状态</p>
</li>
</ul>
<p>1.可以通过调用Thread对象的interrupt（）方法来中断线程，但是此方法只是将中断标志设置为true标志，并不能直接中断线程，若执行interrupt()方法时线程处于：</p>
<ul>
<li><p>未阻塞状态，那么此时阻塞标志已经设为true，等到下一次阻塞状态来临时，就会直接抛出InterruptedException异常，但是只会被捕捉到，可以在catch块内自行return来结束run方法，否则，只是异常被捕捉，线程仍然可以继续往下执行</p>
</li>
<li><p>可中断的阻塞状态，线程收到中断信号后,会立即抛出InterruptedException, 同时会把中断状态置回为false。</p>
</li>
<li><p>不可中断的阻塞状态，不抛出InterruptedException，也不会退出阻塞状态</p>
</li>
</ul>
<p>2.检查中断状态：</p>
<ul>
<li><p>使用 Thread对象的isInterrupted()方法判断中断状态，当调用了interrupt()，isInterrupted()返回true，一旦抛出中断异常中断标志被置为false，isInterrupted()返回false</p>
</li>
<li><p>Thread.interrupted()只是静态方法，只用来判断当前调用它的线程的中断状态，和Thread对象的isInterrupted不同的是，它在每次调用一定会将中断状态置为false</p>
</li>
</ul>
<p>##<strong>4.守护线程</strong><br>Java中有两类线程：</p>
<p>1.用户线程：运行在前台的线程<br>2.守护线程：运行在后台的线程，并为前台线程的运行提供便利服务（比如垃圾回收线程），当所有的用户线程都结束了，那么守护线程也会结束，因为被守护者没有了。因此，不要在守护线程中执行业务逻辑操作（比如对数据的读写等）。</p>
<ul>
<li>可以用Thread对象的setDaemon（true）方法设置当前线程为守护线程，但要在start()之前，否则无效.</li>
<li>在守护线程中创建的子线程也是守护线程</li>
<li>不是所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑</li>
<li>后台进程在不执行finally子句的情况下就会终止其run()方法</li>
</ul>
<p>##<strong>5.同步机制</strong></p>
<p>###<strong>1.原子性和可见性</strong></p>
<ul>
<li><p><strong>原子性</strong>，<strong>不能被线程调度器中断的操作，是不可分割的</strong>。由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、和write这六个，基本数据类型的访问读写是具备原子性的（long和double）的非原子性协定例外），synchronized块之间的操作也具备原子性</p>
</li>
<li><p><strong>可见性</strong>，Java允许多个线程保存共享成员变量的<strong>私有拷贝</strong>,等到进行完操作后，再赋值回主存(减少了同主存通信的次数,提高了运行的速度）。因此线程对变量的修改是互相<strong>不可见的</strong>，在赋值的时候就会发生覆盖，这样就引出一个问题-<strong>变量可见性</strong>。<strong>因此，当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，就称这个变量具有可见性</strong>。</p>
</li>
</ul>
<p>###<strong>2.volatile关键字</strong></p>
<pre><code>private volatile boolean value;  
</code></pre><p>volatile关键字<strong>具有可见性</strong>,被它修饰的变量不能被线程拷贝，即直接在主存读和写，保证了新值能立即刷新，每个线程时刻看到的都是<strong>最新值</strong>。因此，保证了多线程操作时变量的<strong>可见性</strong>，而<strong>不具有原子性</strong>，因为它不会阻塞线程，是一种稍弱的同步机制，要使volatile变量提供理想的线程安全(同时可见性和原子性)，必须同时满足下面两个条件，否则要加锁来保证原子性：</p>
<ul>
<li>对变量的写操作不依赖于当前值。例如自增操作就依赖当前值，因为它是一个读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>
<p>###<strong>3.synchronised关键字</strong></p>
<p>采用synchronized修饰符实现的同步机制叫做互斥锁机制，每一个对象都有一个monitor(锁标记)，只能分配给一个线程。当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池，因此叫做互斥锁，synchronised同时具有可见性和原子性，原子性是因为锁内的操作不可分割，可见性因为 <strong>入锁(进入synchronized)</strong>会获取主存中变量的最新值和<strong>出锁(退出synchronized)</strong>会将变量的最新值刷新回主存</p>
<p>1.实例方法的同步与实例方法内的同步块<br>实例方法内的synchronized是同步在某个实例对象上。即<strong>对象锁</strong></p>
<pre><code>public class MyClass {
public synchronized void log1(String msg1, String msg2){
        //...
}
public void log2(String msg1, String msg2){
        synchronized(object){
            //...
        }
    }}
</code></pre><p>2.静态方法的同步与静态方法内的同步块<br>静态方法内的synchronized是同步在类对象上，锁住的是整个类，即<strong>类锁</strong><br>    public class MyClass {</p>
<pre><code>public static synchronized void log1(String msg1, String msg2){
        //...
}
public void log2(String msg1, String msg2){
        synchronized(MyClass.class){
            //...
        }
    }
}
</code></pre><p>使用同步机制获取互斥锁的情况，进行几点说明：</p>
<ul>
<li><p>一旦某个<strong>锁</strong>被某个线程获取，那么其他所有在<strong>这个锁(同一个对象或类)</strong>上竞争的线程都会阻塞,不管是不是同一个方法或代码块(仔细体会)。以对象锁为例，假如有三个synchronized方法a，b，c，当线程A进入实例对象M中的方法a时，它便获得了该M对象锁，其他的线程会在M的所有的synchronized方法处阻塞，即在方法 a，b，c 处都要阻塞</p>
</li>
<li><p>对象级别锁，锁住的是对象，有上面说的锁的特性.</p>
</li>
<li><p>类级别锁,锁住的是整个类，它用于控制对 static 成员变量以及 static 方法的并发访问。有上面说的锁的特性</p>
</li>
<li><p>互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行 monitorenter指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加 1，相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁便被释放了。由于synchronized同步块对<strong>同一个线程是可重入的</strong>，一个线程可以多次获得同一个对象的互斥锁，要释放相应次数的该互斥锁，才能最终释放掉该锁。</p>
</li>
</ul>
<p>###<strong>4.显示的Lock锁</strong></p>
<ul>
<li><p>unlock()需放在finally子句中，try中必须有return，以确保unlock()不会过早的发生。</p>
</li>
<li><p>显示的Lock对象在加锁和释放锁方面，相比synchronized，还赋予了更细粒度的控制力。</p>
</li>
<li><p>Lock对象必须被显示的创建、锁定和释放。相比synchronized，代码缺乏优雅性。</p>
</li>
<li><p>在使用Lock锁时，某些事物失败抛出一个异常，可以使用finally去做清理工作，以维护系统使其处于良好的状态，<strong>这是synchronized不具有的</strong></p>
</li>
<li><p>ReentrantLock允许尝试获取但最终未获取锁，如果其他线程已经获取这个锁，可以决定离开去执行其他一些事情，而不是等待锁被释放。<strong>这是synchronized不具有的</strong></p>
</li>
</ul>
<p>###<strong>5.synchronized 和 Volatile的比较</strong></p>
<ul>
<li><p>在访问volatile变量时不会执行加锁操作，因此也不会使线程阻塞。</p>
</li>
<li><p>加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。</p>
</li>
<li><p>如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才使用它</p>
</li>
<li><p>在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，</p>
</li>
</ul>
<p>###<strong>6.TheadLocal</strong><br>ThreadLocal类的实例，即便被多个线程锁共享，但是在每个线程当中都有一份私有拷贝，并且多个线程无法看到对方的值，即线程对于此变量的使用完全是在自己拷贝对象上。</p>
<pre><code>private ThreadLocal myThreadLocal = new ThreadLocal();
</code></pre><p>ThreadLocal可以储存任意对象</p>
<pre><code>myThreadLocal.set(&quot;A thread local value&quot;);//存储此对象的值
String threadLocalValue = (String) myThreadLocal.get();//读取
ThreadLocal myThreadLocal1 = new ThreadLocal&lt;String&gt;();//泛型使用
</code></pre><p>###<strong>7.死锁</strong></p>
<p>####<strong>1.普通循环等待死锁</strong><br>如果在同一时间，线程A持有锁M并且想获得锁N，线程B持有锁N并且想获得锁M，那么这两个线程将永远等待下去，这种情况就是最简单的死锁形式。</p>
<pre><code>public class DeadLock{
private final Object left = new Object();
private final Object right = new Object();

public void leftRight() throws Exception
{
    synchronized (left)
    {
        Thread.sleep(2000);
        synchronized (right)
        {
            System.out.println(&quot;leftRight end!&quot;);
        }
    }
}

public void rightLeft() throws Exception
{
    synchronized (right)
    {
        Thread.sleep(2000);
        synchronized (left)
        {
            System.out.println(&quot;rightLeft end!&quot;);
        }
    }
}
}
</code></pre><p>死锁的四个必要条件：</p>
<ul>
<li>互斥条件：线程对所分配到的资源进行排他性使用，即在一段时间内，某资源只能被一个线程占用。如果此时还有其它线程请求该资源，则只能等待，直到占有该资源的线程用毕释放。</li>
<li>请求和保持条件：已经保持了至少一个资源，但是又提出新的资源请求，而资源已被其他线程占有，此时请求线程只能等待，但对自己已获得的资源保持不放。</li>
<li>不可抢占条件：线程已获得的资源在未使用完之前不能被抢占，只能线程使用完之后自己释放。</li>
<li>循环等待条件：在发生死锁时，一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到有一个任务所持有的资源，使得大家被锁住。</li>
</ul>
<p>避免死锁的方式：<br>1、只在必要的最短时间内持有锁，考虑使用同步语句块代替整个同步方法；<br>2、设计时考虑清楚锁的顺序，尽量减少潜在的加锁交互数量<br>3、既然死锁的产生是两个线程无限等待对方持有的锁，我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个<strong>超时时限</strong>，获取锁超时后会返回一个失败信息，放弃取锁。</p>
<p>####<strong>2.重入锁死</strong><br>如果一个线程在两次调用lock()间没有调用unlock()方法，那么第二次调用lock()就会被阻塞，这就出现了重入锁死。避免重入锁死有两个选择：</p>
<ul>
<li>编写代码时避免再次获取已经持有的锁</li>
<li>使用可重入锁</li>
</ul>
<p>###<strong>8.多线程集合的安全使用</strong><br>在 Collections 类中有多个静态方法，它们可以获取通过同步方法封装非同步集合而得到的集合：<br>public static Collection synchronizedCollention(Collection c)<br>public static List synchronizedList(list l)<br>public static Map synchronizedMap(Map m)<br>public static Set synchronizedSet(Set s)<br>public static SortedMap synchronizedSortedMap(SortedMap sm)<br>public static SortedSet synchronizedSortedSet(SortedSet ss)</p>
<p>在多线程环境中，当遍历当前集合中的元素时，希望阻止其他线程添加或删除元素。安全遍历的实现方法如下：</p>
<pre><code>import java.util.*;  

public class SafeCollectionIteration extends Object {  
public static void main(String[] args) {  
    //为了安全起见，仅使用同步列表的一个引用，这样可以确保控制了所有访问  
    //集合必须同步化，这里是一个List  
    List wordList = Collections.synchronizedList(newArrayList());  

    //wordList中的add方法是同步方法，会自动获取wordList实例的对象锁  
    wordList.add(&quot;Iterators&quot;);  
    wordList.add(&quot;require&quot;);  
    wordList.add(&quot;special&quot;);  
    wordList.add(&quot;handling&quot;);  

    //获取wordList实例的对象锁，  
    //迭代时，此时必须阻塞其他线程调用add或remove等方法修改元素
    synchronized ( wordList ) {  
        Iterator iter = wordList.iterator();  
        while ( iter.hasNext() ) {  
            String s = (String) iter.next();  
            System.out.println(&quot;found string: &quot; + s + &quot;, length=&quot; + s.length());  
        }  
    }  
}  
} 
</code></pre><p>大部分的线程安全类都是相对线程安全的，也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现·ConcurrentModificationException·，也就是fail-fast机制</p>
<p>##<strong>6.多线程协作</strong></p>
<p>###<strong>1.wait、notify、notifyAll的使用</strong><br>wait()：将当前线程置入休眠状态，直到接到唤醒通知或被中断为止。调用后当前线程立即释放锁。</p>
<p>notify()：用来通知那些正在等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个wait()状态的线程来发出通知唤醒它。其他线程继续阻塞，但是调用后当前线程<strong>不会立马释放该对象锁</strong>，直到程序<strong>出锁</strong></p>
<p>notifyAll()：notifyAll会使在该对象锁上wait的所有线程统统退出wait的状态(即全部被唤醒),待程序出锁后，所有被唤醒的线程共同竞争该锁，没有竞争到锁的线程会<strong>一直竞争（不是阻塞）</strong></p>
<p>注意：在调用wait、notify、notifyAll方法之前，<strong>必须先获得对象锁</strong>，并且<strong>只能在synchronized代码块或者方法中调用</strong>。否则抛出IllegalMonitorStateException异常</p>
<p>总结：</p>
<ul>
<li><p>如果线程调用了对象的wait()方法，那么该线程便会处于该对象的 <strong>等待池</strong> 中，<strong>等待池中的线程不会去竞争该对象的锁。</strong></p>
</li>
<li><p>如果线程调用了对象的notifyAll()方法（唤醒所有wait线程）或notify()方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的<strong>锁池</strong>中，<strong>锁池中的线程会去竞争该对象锁。</strong></p>
</li>
<li><p>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中。</p>
</li>
</ul>
<p>###<strong>2.notify 通知的遗漏</strong><br>当线程 A 还没开始 wait 的时候，线程 B 已经 notify 了，这样，线程 B 的通知是没有任何响应的，当 线程B 退出 synchronized 代码块后，线程A 再开始 wait，便会一直阻塞等待。也就是说这个通知信号提前来了，没有wait线程收到，因此丢失了信号，为了避免丢失信号，可以设置一个成员变量来标志信号。</p>
<pre><code>public class MyWaitNotify{
MonitorObject myMonitorObject = new MonitorObject();

//一旦调用notify，则设为true表示唤醒信号发出来了，则设为false表示唤醒信号已经被其他某个线程消耗了，
boolean wasSignalled = false;
public void doWait(){
    synchronized(myMonitorObject){
    //自旋锁,循环检查，只有当为true时才表示有唤醒信号来了
    while(!wasSignalled){
             try{
               myMonitorObject.wait();
           } catch(InterruptedException e){...}
          }
       //clear signal and continue running.
         wasSignalled = false;
  }
 }
 public void doNotify(){
     synchronized(myMonitorObject){
        wasSignalled = true;
        myMonitorObject.notify();
   }
 }
}
</code></pre><p>如果有多个线程被notifyAll()唤醒，所有被唤醒的线程都会在while循环里检查wasSignalled变量值，但是只有一个线程可以获得对象锁并且<strong>退出wait()方法并清除wasSignalled标志（设为false）</strong>。这时这个标志已经被第一个唤醒的线程消耗了，所以其余的线程会检查到标志为false，还是会回到等待状态。</p>
<p>###<strong>3.字符串常量或全局对象作为锁的隐患</strong><br><strong>字符串常量</strong>和<strong>全局对象</strong>在不同的实例当中是<strong>同一个对象，即其实用的是同一把锁</strong>。因此本来在不同实例对象的线程会互相干扰，例如在实例A中的线程调用notifyAll()可能会唤醒实例B当中的wait线程。因此应该避免使用这两种对象作为监视器对象，而应使用每个实例中唯一的对象</p>
<pre><code>String myMonitorObject = &quot;&quot;;//相同String 常量赋值在内存当中只会有一份对象
</code></pre><p>###<strong>4.生产者-消费者模型synchronized实现</strong><br>生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。问题在于如何通过线程之间的协作使得生产和消费轮流进行。</p>
<pre><code>package job_3;

import java.util.Random;

public class Datebuf {
private Integer i = 0;
private int result;
private Random random;

public Datebuf() {
    random = new Random();
}

public void sendData() {
    while (!Thread.interrupted()) {
        synchronized (this) {
            try {
                while (i != 0) {
                    this.wait();
                }
                i = random.nextInt(100);
                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName()
                        + &quot;生产&quot; + i);
                this.notify();
            } catch (InterruptedException e) {
                return;
            }
        }
    }
}

public void addData() {
    while (!Thread.interrupted()) {
        synchronized (this) {
            try {
                while (i == 0) {
                    this.wait();
                }
                result += i;
                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName()
                        + &quot;消费&quot; + i + &quot;--result=&quot; + result);
                i = 0;
                this.notify();
            } catch (InterruptedException e) {
                return;
            }
        }
    }
}
</code></pre><p>}</p>
<p>###<strong>5.其他协调方法</strong><br>1.join()<br>一个线程可以调用其他线程的join()方法，其效果是等待其他线程结束才继续执行。如果某个线程调用t.join()，此线程将被挂起，直到目标线程t结束才恢复（即t.isAlive()为假）。</p>
<p>2.yield()<br>建议线程调度器让其他具有相同优先级的线程优先运行，但只是建议，并不一定就是别的线程先运行了</p>
<p>##7.线程池</p>
<p>###<strong>1.ExecutorService介绍</strong><br>ExecutorService的生命周期包括三种状态：运行，关闭，终止。创建后便进入了运行状态，当调用了 shutdown()方法时，便进入关闭状态。</p>
<p>使用线程池的好处:</p>
<ul>
<li>降低资源消耗。通过重复利用已创的线程降低线程创建和销毁在成的消耗</li>
<li>提高响应速度。当任务到达的时候，不需要再去创建线程就能立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控</li>
</ul>
<p>###<strong>2.自定义线程池</strong></p>
<pre><code>public ThreadPoolExecutor (
            int corePoolSize, 
            int maximumPoolSize, 
            long keepAliveTime, 
            TimeUnit unit,
            BlockingQueue&lt;Runnable&gt; workQueue)
</code></pre><ul>
<li><p>corePoolSize：线程池中所保存的<strong>核心线程数</strong>，包括空闲线程。</p>
</li>
<li><p>maximumPoolSize：池中允许的<strong>最大线程数</strong>。</p>
</li>
<li><p>keepAliveTime：线程池中的<strong>空闲线程所能持续的最长时间</strong>，超过将被线程池移除,可以通过调大此值来提高线程的利用率。</p>
</li>
<li><p>unit：<strong>持续时间的单位</strong>。</p>
</li>
<li><p>workQueue：任务执行前<strong>保存任务的队列</strong>，仅保存由 execute 方法提交的 Runnable 任务。</p>
<ul>
<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
</li>
<li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态(缓冲区为1的生产者消费者模式)</p>
</li>
<li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p>
</li>
</ul>
</li>
<li>饱和策略<ul>
<li>AbortPolicy： 直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久</li>
</ul>
</li>
</ul>
<p>###<strong>3.创建线程池</strong></p>
<p>以下四个线程池底层都是调用了ThreadPoolExecutor的构造方法，所以它们主要只是参构造数设置上的差异，理解了它们的默认构造参数值就能明白它们的区别</p>
<p><strong>newCachedThreadPool()</strong></p>
<pre><code>public static ExecutorService newCachedThreadPool() {
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                            60L, TimeUnit.SECONDS,
                            new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><ul>
<li>直接提交策略SynchronousQueue,无界线程池(maximumPoolSize无限大)，可以进行自动线程回收</li>
</ul>
<p><strong>newFixedThreadPool(int)</strong></p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre><ul>
<li>使用了LinkedBlockingQueue无界队列(workQueue无限大)，线程数当超过了coreSize，此队列由于是链式则可以无限添加(资源耗尽，另当别论)，永远也不会触发产生新的线程,且线程结束即死亡不会被重复利用。</li>
</ul>
<p><strong>newScheduledThreadPool(int)</strong></p>
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
</code></pre><p>延迟调用周期执行示例,表示延迟1秒后每3秒执行一次:</p>
<pre><code>scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
           @Override
           public void run() {
System.out.println(&quot;delay 1 seconds, and excute every 3     seconds&quot;);
}
}, 1, 3, TimeUnit.SECONDS);
</code></pre><ul>
<li>定长调度型线程池，这个池子里的线程可以按 schedule 依次 delay 执行，或周期执行,这是特殊的DelayedWorkQueue的效果.</li>
</ul>
<p><strong>SingleThreadExecutor()</strong></p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService(
    new ThreadPoolExecutor(1, 1,0L, 
    TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre><ul>
<li>单例线程，任意时间池中只能有一个线程,如果向该线程池提交了多个任务，这些任务将排队</li>
</ul>
<p>当试图通过 excute 方法将一个 Runnable 任务添加到线程池中时，按照如下顺序来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ex=&gt;start: 提交任务</div><div class="line">co=&gt;condition: 核心线程池满了？</div><div class="line">new=&gt;operation: 创建新线程</div><div class="line">queue=&gt;condition: 缓冲队列无法加入？</div><div class="line">add=&gt;operation: 加入缓冲队列</div><div class="line">bao=&gt;operation: 饱和政策处理</div><div class="line">max=&gt;condition: 最大线程池满了?</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">ex-&gt;co</div><div class="line">co(yes)-&gt;queue</div><div class="line">co(no)-&gt;new</div><div class="line">queue(yes)-&gt;max</div><div class="line">queue(no)-&gt;add</div><div class="line">max(yes)-&gt;bao</div><div class="line">max(no)-&gt;new</div></pre></td></tr></table></figure>
<p>###<strong>4.几种排队的策略</strong></p>
<ul>
<li><p>直接提交。缓冲队列采用 SynchronousQueue，它将任务直接交给线程处理而不保持它们。如果不存在可用于立即运行任务的线程（即无空闲线程），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中。直接提交通常要求无界maximumPoolSizes（Integer.MAX_VALUE） 以避免拒绝新提交的任务。newCachedThreadPool 采用的便是这种策略。</p>
</li>
<li><p>无界队列，典型的便是的LinkedBlockingQueue(链式)，当线程数超过corePoolSize时，新的任务将在缓冲队列无限排队。因此，创建的线程就不会超过corePoolSize，maximumPoolSize的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。newFixedThreadPool采用的便是这种策略。</p>
</li>
<li><p>有界队列。当使用有限的 maximumPoolSizes 时，有界队列（一般缓冲队列使用ArrayBlockingQueue，并制定队列的最大长度）有助于防止资源耗尽，但是可能较难调整和控制，队列大小和最大池大小需要相互折衷，需要设定合理的参数。</p>
</li>
</ul>
<p>###<strong>5.关闭线程池</strong></p>
<ul>
<li>shutdown：不可以再submit新的task，已经submit（分两种，正在运行的和在缓冲队列的）的将继续执行。并interrupt()空闲线程。</li>
<li>shutdownNow：试图停止当前正执行的task，清除未执行的任务并返回尚未执行的task的list。</li>
<li>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true </li>
</ul>
<p>###<strong>6.Executor执行Runnable和Callable任务</strong></p>
<p><strong>Runnable</strong><br>无返回值，无法抛出经过检查的异常，通过execute方法添加</p>
<pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();//创建线程池
executorService.execute(new TestRunnable());//添加任务
</code></pre><p><strong>Callable</strong><br>返回Future对象，获取返回结果时可能会抛出异常，通过submit方法添加</p>
<pre><code>package threadLearn;

import java.util.ArrayList;   
import java.util.List;   
import java.util.concurrent.*;   

public class CallableDemo{   
public static void main(String[] args){   
    ExecutorService executorService=Executors.newCachedThreadPool();   
    List&lt;Future&lt;String&gt;&gt; resultList = new ArrayList&lt;Future&lt;String&gt;&gt;();   
    //创建10个任务并执行   
        for (int i = 0; i &lt; 10; i++){   
        //使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中   
        Future&lt;String&gt; future = executorService.submit(new TaskWithResult(i));   
        //将任务执行结果存储到List中   
        resultList.add(future);   
    }   
    //遍历任务的结果   
    for (Future&lt;String&gt; fs : resultList){   
            try{   
                while(!fs.isDone()){//Future返回如果没有完成，则一直循环等待，直到Future返回完成  
                    System.out.println(&quot;还没完成&quot;);
                }
                System.out.println(fs.get());//打印各个线程（任务）执行的结果   
            }catch(InterruptedException e){   
                e.printStackTrace();   
            }catch(ExecutionException e){   
                e.printStackTrace();   
            }finally{   
                //启动一次顺序关闭，执行以前提交的任务，但不接受新任务  
                executorService.shutdown();   
            }   
    }   
}   
}   

class TaskWithResult implements Callable&lt;String&gt;{   
private int id;   

public TaskWithResult(int id){   
    this.id = id;   
}   

/**  
 * 任务的具体过程，一旦任务传给ExecutorService的submit方法， 
 * 则该方法自动在一个线程上执行 
 */   
public String call() throws Exception {  
    System.out.println(&quot;call()方法被自动调用&quot; + Thread.currentThread().getName());   
    Thread.sleep(1000);
    //该返回结果将被Future的get方法得到  
    return &quot;call()方法被自动调用，任务返回的结果是：&quot; + id + &quot;-----&quot; + Thread.currentThread().getName();   
    }   
} 
</code></pre><p>如果真正的结果的返回尚未完成，则get()方法会阻塞等待，可以通过调用 isDone()方法判断 Future 是否完成了返回。</p>
<p>###<strong>9.线程异常处理</strong></p>
<p>由于线程的本质特性(可以理解不同的线程是平行空间)，从某个线程中逃逸的异常是无法被别的线程捕获的。一旦异常逃出任务的run()方法，就会向外传向控制台。Thread.UncaughtExceptionHandler是JavaSE5中的新接口，它允许在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。</p>
<pre><code>Thread t = new Thread(r);
t.setUncaughtExceptionHandler(new  MyUncaughtExceptionHandler());
</code></pre><p>##<strong>8.Lock 锁与Condition</strong></p>
<p>###<strong>1.Lock锁的介绍</strong><br>Lock接口有3个实现它的类：ReentrantLock、ReetrantReadWriteLock.ReadLock和ReetrantReadWriteLock.WriteLock，即重入锁、读锁和写锁。</p>
<ul>
<li>lock 必须被显式地创建、锁定和释放，为了使用更多的功能，一般用 ReentrantLock 为其实例化</li>
<li>为了保证锁最终一定会被释放（可能会有异常发生），要把互斥区放在 try 语句块内，并在finally语句块中释放锁，尤其当有return语句时，return 语句必须放在try字句中，以确保unlock()不会过早发生，从而将数据暴露给第二个任务。</li>
</ul>
<p>####(1)<strong>ReentrantLock与synchronized的比较</strong></p>
<ul>
<li><p>等待可中断：当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情，由synchronized产生的互斥锁时，会一直阻塞，是不能被中断的</p>
</li>
<li><p>可实现公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序排队等待，通过构造方法 ReentrantLock（ture）来要求使用公平锁</p>
</li>
<li><p>锁可以绑定多个条件：ReentrantLock 对象可以同时绑定多个 Condition 对象（名曰：条件变量或条件队列），我们还可以通过绑定 Condition 对象来判断当前线程通知的是哪些线程（即与Condition对象绑定在一起的其他线程</p>
</li>
</ul>
<p>####(2)<strong>ReetrantLock的忽略中断锁和响应中断锁</strong><br>忽略中断锁与 synchronized实现的互斥锁一样，不能响应中断，而响应中断锁可以响应中断。</p>
<pre><code>ReentrantLock lock = new ReentrantLock();  
lock.lockInterruptibly();//获取响应中断锁  
</code></pre><p>####(3)<strong>读写锁</strong><br>  用读锁来锁定读操作，用写锁来锁定写操作，这样写操作和写操作之间会互斥，读操作和写操作之间会互斥，但读操作和读操作就不会互斥。</p>
<pre><code>ReadWriteLock rwl = new ReentrantReadWriteLock();  
rwl.writeLock().lock()  //获取写锁  
rwl.readLock().lock()  //获取读锁 
</code></pre><p>###2.<strong>生产者-消费者模型Lock与Condition实现</strong></p>
<pre><code>package job_3;
import java.util.Random;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class LockDatebuf implements Data {
private Integer i = 0;
private int result;
private Random random;
private ReentrantLock lock = new ReentrantLock();
private Condition condition = lock.newCondition();
public LockDatebuf() {
    random = new Random();
}

public void sendData() throws InterruptedException {
    while (!Thread.interrupted()) {
        lock.lockInterruptibly();
            try {
                while (i != 0) {
                    condition.await();
                }
                i = random.nextInt(100);
                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName()
                        + &quot;生产&quot; + i);
                condition.signal();
            } catch (InterruptedException e) {

            }finally{
                lock.unlock();
            }
    }
}

public void addData() throws InterruptedException {
    while (!Thread.interrupted()) {
        lock.lockInterruptibly();
            try {
                while (i == 0) {
                    condition.await();
                }
                result += i;
                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName()
                        + &quot;消费&quot; + i + &quot;--result=&quot; + result);
                i = 0;
                condition.signal();
            } catch (InterruptedException e) {

            }finally{
                lock.unlock();
            }
    }
}
}
</code></pre><p>##<strong>9.并发新特性</strong></p>
<p>###<strong>1.CountDownLatch</strong><br>可以让一组任务必须在另一组任务全部结束后才开始执行，向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用await()方法的线程都将阻塞，直至计数值子减为0。其他任务在结束其工作时，可以调用countDown()来减小这个计数值。CountDownLatch被设计为只触发一次。</p>
<pre><code>package threadLearn;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

class CountDownLatchTest {
public static void main(String[] args) throws InterruptedException {
    // 只触发一次，计数值不能被重置
    int size = 5;
    CountDownLatch latch = new CountDownLatch(size);
    ExecutorService exec = Executors.newCachedThreadPool();
    exec.execute(new Waiting(latch,&quot;wait线程&quot;));
    for (int i = 0; i &lt; size; i++) {
        exec.execute(new OtherTask(latch));
    }
    TimeUnit.SECONDS.sleep(1);
    exec.shutdown();
}
}

class Waiting implements Runnable {
    private CountDownLatch latch;
    private String name;
    public Waiting(CountDownLatch latch,String name) {
        this.latch = latch;
        this.name = name;
    }
    public void run() {
        try {
            latch.await();
            System.out.println(name+&quot;最后执行的任务...&quot;);
        } catch (Exception e) {
            return;
        }
    }
}

class OtherTask implements Runnable {
    private CountDownLatch latch;
    private Random rand = new Random();
    public OtherTask(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {
        try {
            doWork();
            latch.countDown();
        } catch (Exception e) {
            return;
        }
    }

    private void doWork() throws InterruptedException {
        TimeUnit.MICROSECONDS.sleep(1000);
        System.out.println(Thread.currentThread().getName() + &quot; 执行完毕&quot;);
    }
}
</code></pre><p>###<strong>2.障碍器 CyclicBarrier</strong><br>它适用于这样一种情况：你希望创建一组任务，它们并发地执行工作，另外的一个任务在这一组任务并发执行结束前一直阻塞等待，直到该组任务全部执行结束，这个任务才得以执行。这非常像CountDownLatch，只是 CountDownLatch是只触发一次的事件，而<strong>CyclicBarrier可以多次重用</strong></p>
<pre><code>package threadLearn;
import java.util.concurrent.BrokenBarrierException;   
import java.util.concurrent.CyclicBarrier;   
public class CyclicBarrierTest {   
    public static void main(String[] args) {   
            //创建CyclicBarrier对象，  
            //并设置执行完一组5个线程的并发任务后，再执行MainTask任务  
            CyclicBarrier cb = new CyclicBarrier(5, new MainTask());   
            new SubTask(&quot;A&quot;, cb).start();   
            new SubTask(&quot;B&quot;, cb).start();   
            new SubTask(&quot;C&quot;, cb).start();   
            new SubTask(&quot;D&quot;, cb).start();   
            new SubTask(&quot;E&quot;, cb).start();  
    }   
}   

/**  
* 最后执行的任务 
*/   
class MainTask implements Runnable {   
    public void run() {   
            System.out.println(&quot;......终于要执行最后的任务了...    ...&quot;);   
    }   
}   

/**  
* 一组并发任务  
*/   
class SubTask extends Thread {   
    private String name;   
    private CyclicBarrier cb;   

    SubTask(String name, CyclicBarrier cb) {   
            this.name = name;   
            this.cb = cb;   
    }   

    public void run() {   
            System.out.println(&quot;[并发任务&quot; + name + &quot;]  开始执行&quot;);   
            for (int i = 0; i &lt; 999999; i++) ;    //模拟耗时的任务   
            System.out.println(&quot;[并发任务&quot; + name + &quot;]  开始执行完毕，通知障碍器&quot;);   
            try {   
                    //每执行完一项任务就通知障碍器   
                    cb.await();   
            } catch (InterruptedException e) {   
                    e.printStackTrace();   
            } catch (BrokenBarrierException e) {   
                    e.printStackTrace();   
            }   
    }   
}  
</code></pre><p>###<strong>3.信号量Semaphore</strong></p>
<p>信号量 Semaphore 实际上是一个功能完毕的计数信号量，从概念上讲，它维护了一个许可集合，对控制一定资源的消费与回收有着很重要的意义。Semaphore 可以控制某个资源被同时访问的任务数，它通过acquire()获取一个许可，release()释放一个许可。如果被同时访问的任务数已满，则其他 acquire 的任务进入等待状态，直到有一个任务被release掉，它才能得到许可。Semaphore 仅仅是对资源的并发访问的任务数进行监控，而不会保证线程安全，因此，在访问的时候，要自己控制线程的安全访问。</p>
<p>##<strong>10.性能调优</strong></p>
<p>###<strong>(1)比较各类互斥技术</strong></p>
<ul>
<li><p>Atomic类<br>不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。缺点是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p>
</li>
<li><p>关键字synchronized<br>在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，原因在于，编译程序通常会尽可能的进行优化synchronize</p>
</li>
<li><p>Lock<br>在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态。ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。ReentrantLock拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候。可以被中断。</p>
</li>
</ul>
<p>###<strong>(2)免锁容器</strong></p>
<p>CopyOnWiteArrayList的写入将导致创建整个底层数组的副本，而原数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全的执行。当修改完成时，一个原子性的操作把新的数组换入，使得新的读取操作可以看到这个新的修改。</p>
<ul>
<li>好处是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。</li>
<li>CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁行为。</li>
<li>ConcurrenHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改。在修改完成之前，读取者仍旧不能看到他们。</li>
</ul>
<p>###<strong>(3)ReadWriteLock</strong></p>
<p>对向数据结构相对不频繁的写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读者，只要他们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读者都不能访问，直至这个写锁被释放为止。即适用于读者多于写者的情况。</p>
<p>对于ReadWriteLock的应用主要是：缓存和提高对数据结构的并发性。</p>
<ul>
<li><p>锁降级：重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</p>
</li>
<li><p>锁获取的中断：读取锁和写入锁都支持锁获取期间的中断。</p>
</li>
<li>Condition 支持 ：写入锁提供了一个Condition实现，对于写入锁来说，该实现的行为与 ReentrantLock.newCondition() 提供的 Condition 实现对 ReentrantLock 所做的行为相同。当然，此 Condition 只能用于写入锁。<br>读取锁不支持 Condition，readLock().newCondition() 会抛出 UnsupportedOperationException。</li>
<li>重入：此锁允许 reader 和 writer 按照 ReentrantLock 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入 reader 使用它们。</li>
</ul>
<p>下面的代码展示了如何利用重入来执行锁降级：</p>
<pre><code>class CachedData {
Object data;
volatile boolean cacheValid;
ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

void processCachedData() {
    rwl.readLock().lock();
    if (!cacheValid) {
    //在获取写锁之前必须释放读锁
        rwl.readLock().unlock();
        rwl.writeLock().lock();
        // 重新检查状态，因为可能其他线程已经获取到读锁了
        if (!cacheValid) {
            data = ...
            cacheValid = true;
        }
        rwl.readLock().lock();
        rwl.writeLock().unlock(); 
    }
    use(data);
    rwl.readLock().unlock();
}
</code></pre><p>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##&lt;strong&gt;1.多线程的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源利用率更好&lt;/li&gt;
&lt;li&gt;程序在某些情况下更简单&lt;/li&gt;
&lt;li&gt;程序响应更快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-创建线程&quot;&gt;&lt;a href=&quot;#2-创建线程&quot; class=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 秒级编译方案-Freeline安装使用</title>
    <link href="http://yoursite.com/2016/12/08/Android%20%E7%A7%92%E7%BA%A7%E7%BC%96%E8%AF%91%E6%96%B9%E6%A1%88-Freeline%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/12/08/Android 秒级编译方案-Freeline安装使用/</id>
    <published>2016-12-07T16:20:21.000Z</published>
    <updated>2016-12-07T17:28:18.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-秒级编译方案-Freeline安装使用"><a href="#Android-秒级编译方案-Freeline安装使用" class="headerlink" title="Android 秒级编译方案-Freeline安装使用"></a>Android 秒级编译方案-Freeline安装使用</h1><hr>
<h2 id="什么是Freeline？"><a href="#什么是Freeline？" class="headerlink" title="什么是Freeline？"></a>什么是Freeline？</h2><p>Freeline是由蚂蚁聚宝Android团队开发的一款针对Android平台的增量编译工具。它可以充分利用缓存文件，在几秒钟内迅速地对代码的改动进行编译并部署到设备上，有效地减少了日常开发中的大量重新编译与安装的耗时。Freeline能够为Android开发者节省很多喝杯咖啡的时间 : )</p>
<p>Freeline将整个编译过程拆分成多个小模块，根据模块间的依赖关系并发进行编译任务。它可以对所有编译缓存文件做到充分地利用，真正地做到了“增量”编译。同时，它也提取了buck的部分组件（dx与DexMerger），来加速构建流程。Freeline会在app运行时启动一条独立进程来运行Socket Server以进行开发机与app的通信，同时也能确保即使在app出现crash之后，仍然能够使增量编译持续生效。</p>
<p>Freeline是通过multi-dex的方案来实现Java代码的增量更新的。与此同时，我们也专门对aapt工具做了深度优化，给出了独立的FreelineAapt资源打包工具用来生成增量的资源包以及加快资源包的打包速度。运行期的资源替换，Freeline中使用了Instant-Run的方案。除此之外，Freeline也支持运行期动态更新so文件。</p>
<p>Freeline会根据代码文件的变更情况，自动在全量编译与增量编译中进行切换。</p>
<p>实际上，Freeline可以在经过简单的改造之后，作为线上热修复方案，通过动态下发增量资源，来对应用进行修复或者资源替换。经过压缩后的增量资源通常都会在100kb以下，用户可以在移动网络的环境下直接接收到热补丁。蚂蚁聚宝已经基于Freeline打造了完整的热修复框架，应用于线上问题修复以及A/B Test。</p>
<h2 id="如何使用Freeline？"><a href="#如何使用Freeline？" class="headerlink" title="如何使用Freeline？"></a>如何使用Freeline？</h2><p><br> </p>
<h3 id="1-在project-level的build-gradle中添加以下代码"><a href="#1-在project-level的build-gradle中添加以下代码" class="headerlink" title="1.在project-level的build.gradle中添加以下代码"></a>1.在project-level的build.gradle中添加以下代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">'com.antfortune.freeline:gradle:0.8.3'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br> <br> </p>
<h3 id="2-在主module的build-gradle中添加以下代码"><a href="#2-在主module的build-gradle中添加以下代码" class="headerlink" title="2.在主module的build.gradle中添加以下代码"></a>2.在主module的build.gradle中添加以下代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'com.antfortune.freeline'</span></div><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    freeline &#123;</div><div class="line">        hack <span class="keyword">true</span></div><div class="line">        productFlavor <span class="string">"dev"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    ...</div><div class="line">    compile <span class="string">'com.antfortune.freeline:runtime:0.8.3'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br> <br> </p>
<h3 id="3-在app的Application的onCreate方法中初始化Freeline，加入一行代码"><a href="#3-在app的Application的onCreate方法中初始化Freeline，加入一行代码" class="headerlink" title="3.在app的Application的onCreate方法中初始化Freeline，加入一行代码"></a>3.在app的Application的onCreate方法中初始化Freeline，加入一行代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FreelineCore.init(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p><br> <br> </p>
<h3 id="4-下载安装python，由于Freeline在python3-x版本不适用，所以现在还是用python2-7最好"><a href="#4-下载安装python，由于Freeline在python3-x版本不适用，所以现在还是用python2-7最好" class="headerlink" title="4.下载安装python，由于Freeline在python3.x版本不适用，所以现在还是用python2.7最好"></a>4.下载安装python，由于Freeline在python3.x版本不适用，所以现在还是用python2.7最好</h3><p>python2.7下载地址:<br><a href="https://www.python.org/ftp/python/2.7.12/python-2.7.12.msi" target="_blank" rel="external">https://www.python.org/ftp/python/2.7.12/python-2.7.12.msi</a></p>
<p>安装时一路next即可，不过这个地方需要注意下,所有选项都要全部选上如图即可，此处借用廖雪峰老师的图</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/0014222393965540081463bf8a9499094bdda24b6fdf2d6000" alt="安装选项"></p>
<p>然后验证是否安装成功,打开cmd命令窗口,输入python，类似下图即成功</p>
<p><img src="http://img.blog.csdn.net/20161208003416067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNfeGluZ2RlY2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>若出现“python不是外部或内部命令”的提示，则可能是没有python的安装目录添加到path，拷贝python的安装目录如：D:\python(这是我的路径，你的可能不一样)到环境变量path中，别忘了加；哦</p>
<p><br></p>
<h3 id="5-下载Freeline相关所需插件，文件"><a href="#5-下载Freeline相关所需插件，文件" class="headerlink" title="5.下载Freeline相关所需插件，文件"></a>5.下载Freeline相关所需插件，文件</h3><p>打开cmd命令窗口进入工程文件根目录或者直接在android studio中打开Terminal控制台执行以下命令:</p>
<p>gradlew initFreeline</p>
<p>若速度慢，可使用在后面添加参数gradlew initFreeline -Pmirror</p>
<p>此处注意:<br>1.需要gradle-2.14.1及以上，为了方便最好使用本地gradle，如图</p>
<p><img src="http://img.blog.csdn.net/20161208004953669?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNfeGluZ2RlY2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>2.如果出现中途卡住不动的情况，如图</p>
<p><img src="http://img.blog.csdn.net/20161208005108576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNfeGluZ2RlY2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可将工程根目录下的有关freeline的东西全部删除，再手动下载freeline的文件拷贝到工程根目录下<br>freeline依赖下载地址:<a href="https://github.com/alibaba/freeline/releases，下载对应的版本即可" target="_blank" rel="external">https://github.com/alibaba/freeline/releases，下载对应的版本即可</a><br><img src="http://img.blog.csdn.net/20161208010006376?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNfeGluZ2RlY2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后再次执行gradlew initFreeline命令，即可完成安装</p>
<p><br></p>
<h3 id="6-具体使用"><a href="#6-具体使用" class="headerlink" title="6.具体使用"></a>6.具体使用</h3><p>命令行执行:</p>
<p>python freeline.py</p>
<p>即可编译运行到设备上，首次运行可能很慢，后续代码更新就快的飞起啦，有时可能已经安装好了，但没有自动打开，手动打开下就好了</p>
<p>不过这样也是很麻烦，下载freeline的android studio插件更方便快捷，到as插件搜索freeline，安装，重启android studio，然后就会出现这样一个图标，以后编译运行直接点击这个就好了</p>
<p><img src="http://img.blog.csdn.net/20161208011804170?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNfeGluZ2RlY2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><br></p>
<h3 id="其他注意事项："><a href="#其他注意事项：" class="headerlink" title="其他注意事项："></a>其他注意事项：</h3><p>1.如果你的as已经安装了Jrebel的话，先卸载掉，不然可能会出问题</p>
<p>2.把instant run所有选项都去掉，如图</p>
<p><img src="http://img.blog.csdn.net/20161208011048773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNfeGluZ2RlY2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>至此，祝使用愉快！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-秒级编译方案-Freeline安装使用&quot;&gt;&lt;a href=&quot;#Android-秒级编译方案-Freeline安装使用&quot; class=&quot;headerlink&quot; title=&quot;Android 秒级编译方案-Freeline安装使用&quot;&gt;&lt;/a&gt;Andro
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cmd Markdown 编辑阅读器</title>
    <link href="http://yoursite.com/2016/10/31/Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2016/10/31/Cmd Markdown 编辑阅读器/</id>
    <published>2016-10-31T07:21:49.000Z</published>
    <updated>2016-10-31T07:50:32.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>
<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p>
<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>
<h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>
<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>
</blockquote>
<hr>
<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
<h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="external">Todo 列表</a></h3><ul>
<li>[ ] 支持以 PDF 格式导出文稿</li>
<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li>[x] 新增 Todo 列表功能</li>
<li>[x] 修复 LaTex 公式渲染问题</li>
<li>[x] 新增 LaTex 公式编号功能</li>
</ul>
<h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>
<h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># A comment</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="external">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">op=&gt;operation: Your Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="external">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Alice-&gt;Bob: Hello Bob, how are you?</div><div class="line">Note right of Bob: Bob thinks</div><div class="line">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>
<h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="external">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">title 项目开发流程</div><div class="line">section 项目确定</div><div class="line">    需求分析       :a1, 2016-06-22, 3d</div><div class="line">    可行性报告     :after a1, 5d</div><div class="line">    概念验证       : 5d</div><div class="line">section 项目实施</div><div class="line">    概要设计      :2016-07-05  , 5d</div><div class="line">    详细设计      :2016-07-08, 10d</div><div class="line">    编码          :2016-07-15, 10d</div><div class="line">    测试          :2016-07-22, 5d</div><div class="line">section 发布验收</div><div class="line">    发布: 2d</div><div class="line">    验收: 3d</div></pre></td></tr></table></figure>
<h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">\$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">\$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">\$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="external">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="external">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>
<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<hr>
<h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>
<h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>
<h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p>
<h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>
<h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>
<h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>
<h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p>
<p>通过管理工具栏可以：</p>
<p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>
<h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p>
<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>
<p>工具栏上的五个图标依次为：</p>
<p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>
<h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>
<h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>
<p>标签： 未分类</p>
<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>
<p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p>
<h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>
<hr>
<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="external">@ghosert</a><br>2016 年 07月 07日    </p>
<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p>
<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;欢迎使用-Cmd-Markdown-编辑阅读器&quot;&gt;&lt;a href=&quot;#欢迎使用-Cmd-Markdown-编辑阅读器&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用 Cmd Markdown 编辑阅读器&quot;&gt;&lt;/a&gt;欢迎使用 Cmd Markdown
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2016/10/30/hello-world/"/>
    <id>http://yoursite.com/2016/10/30/hello-world/</id>
    <published>2016-10-30T15:55:55.906Z</published>
    <updated>2016-10-30T15:55:55.906Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
